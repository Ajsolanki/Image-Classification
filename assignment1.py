# -*- coding: utf-8 -*-
"""Assignment1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dga_hq-L_fpBDTERq8TDkakB13ueRgiP
"""

from google.colab import files
category_1 = files.upload()

import cv2
import os

def image_processing(raw_data,data_path,height,width):
    class_labels=[]
    category_count=0
    for i in os.walk(raw_data):
        if len(i[2])>2:
            counter=0
            images=i[2]
            class_name=i[0].strip()
            print(class_name)
            path=os.path.join(data_path,class_labels[category_count])
            for image in images:
              if '.png' not in image:
                continue
              else:
                im=cv2.imread(class_name+'/'+image, cv2.IMREAD_GRAYSCALE)
                im=cv2.resize(im,(height,width))
                if not os.path.exists(path):
                    os.makedirs(path)
                cv2.imwrite(os.path.join(path,str(counter)+'.jpg'),im)
                counter+=1
            category_count+=1
        else:
            number_of_classes=len(i[1])
            print(number_of_classes,i[1])       
            class_labels=i[1][:]

if __name__=='__main__':
    height = 100
    width = 100
    raw_data = '/content/drive/My Drive/Dataset/test'
    data_path = '/content/reduced_Image'
    if not os.path.exists(data_path):
        image_processing(raw_data, data_path, height, width)

path = '/content/drive/My Drive/Dataset/test'
counter = 1
for i in os.walk(path):
  img_list = i[2]
  for image in img_list:
    if '.png' not in image:
      continue
    else:
      img = cv2.imread(os.path.join(path,image), cv2.IMREAD_GRAYSCALE)
      img = cv2.resize(img, (100,100))
      if not os.path.exists('/content/test_image'):
        os.makedirs('/content/test_image')
      cv2.imwrite(os.path.join('/content/test_image', str(counter)+ '.jpg'), img)
      counter += 1



import tensorflow as tf
from tensorflow.python.client import device_lib
import random
import os, cv2
import numpy as np
import pandas as pd

#Session start 
session = tf.Session()

data_path = '/content/reduced_test_Image'
all_classes = os.listdir(r'/content/reduced_test_Image')
height,width = 100, 100
color_channels = 3
number_of_classes = len(all_classes)

epochs=300
batch_size=10
batch_counter=0
model_save_name='model_checkpoint/'


#create Placeholders for images and labels
images_ph=tf.placeholder(tf.float32,shape=[None,height,width,color_channels])
labels_ph=tf.placeholder(tf.float32,shape=[None,number_of_classes])

#Model Unit's 

class model_tools:
  #Define functions for all the tensorflow components 
  
  def add_weights(self, shape):
        # takes in shapes of previous and new layer as a list e.g. [2,10]
        return tf.Variable(tf.truncated_normal(shape=shape, stddev=0.05))
  
  def add_biases(self,shape):
        # takes in shape of the current layer e.g. x=10 and add bias with default = 0.05
        return tf.Variable(tf.constant(0.05, shape=shape))

  def conv_layer(self,layer, kernel, input_shape, output_shape, stride_size):
        #create weights and biases for the given layer shape
        weights = self.add_weights([kernel, kernel, input_shape, output_shape])
        biases = self.add_biases([output_shape])

        #stride=[image_jump,row_jump,column_jump,color_jump]=[1,1,1,1]
        stride = [1, stride_size, stride_size, 1]

        layer = tf.nn.conv2d(layer, weights, strides=stride, padding='SAME') + biases
        return layer
  
  def pooling_layer(self,layer, kernel_size, stride_size):
        #kernel=[image_jump,rows,columns,depth]
        kernel = [1, kernel_size, kernel_size, 1]
        
        #stride=[image_jump,row_jump,column_jump,color_jump]=[1,2,2,1] mostly
        stride = [1, stride_size, stride_size, 1]
        
        #Max pooling takes the maximum of the kernel
        return tf.nn.max_pool(layer, ksize=kernel, strides=stride, padding='SAME')

  def flattening_layer(self,layer):
        #for flatten for the input(single dimensional)
        input_size = layer.get_shape().as_list()
        new_size = input_size[-1] * input_size[-2] * input_size[-3]
        return tf.reshape(layer, [-1, new_size]),new_size

  def fully_connected_layer(self,layer, input_shape, output_shape):
        #create weights and biases for the given layer shape
        weights = self.add_weights([input_shape, output_shape])
        biases = self.add_biases([output_shape])
        
        layer = tf.matmul(layer,weights) + biases  # mX+b
        return layer

  def activation_layer(self,layer):
        #use Rectified linear unit Relu
        return tf.nn.relu(layer)
  pass

#tools for image processing and data handing.
class utils:
    image_count = []
    count_buffer=[]
    class_buffer=all_classes[:]
    def __init__(self):
        self.image_count = []
        self.count_buffer = []
        for i in os.walk(data_path):
            if len(i[2]):
                self.image_count.append(len(i[2]))
        self.count_buffer=self.image_count[:]

    # processing images into arrays and dispatch as batches whenever called.
    def batch_dispatch(self,batch_size=batch_size):
      
        global batch_counter
        if sum(self.count_buffer):
            class_name = random.choice(self.class_buffer)
            choice_index = all_classes.index(class_name)
            choice_count = self.count_buffer[choice_index]
            if choice_count==0:
                class_name=all_classes[self.count_buffer.index(max(self.count_buffer))]
                choice_index = all_classes.index(class_name)
                choice_count = self.count_buffer[choice_index]

            slicer=batch_size if batch_size<choice_count else choice_count
            img_ind=self.image_count[choice_index]-choice_count
            indices=[img_ind,img_ind+slicer]
            images = self.generate_images(class_name,indices)
            labels = self.generate_labels(class_name,slicer)

            self.count_buffer[choice_index]=self.count_buffer[choice_index]-slicer
        else:
            images,labels=(None,)*2
        return images, labels

    #gives one hot for the respective labels
    def generate_labels(self,class_name,number_of_samples):
        one_hot_labels=[0]*number_of_classes
        one_hot_labels[all_classes.index(class_name)]=1
        one_hot_labels=[one_hot_labels]*number_of_samples
        #one_hot_labels=tf.one_hot(indices=[all_classes.index(class_name)]*number_of_samples,depth=number_of_classes)
        return one_hot_labels

    # image operations
    def generate_images(self,class_name,indices):
        batch_images=[]
        choice_folder=os.path.join(data_path,class_name)
        selected_images=os.listdir(choice_folder)[indices[0]:indices[1]]
        for image in selected_images:
            img=cv2.imread(os.path.join(choice_folder,image))
            batch_images.append(img)
        return batch_images

#Model Creation

def generate_model():
    #MODEL ARCHITECTURE:
    
    #level 1 convolution layer
    network = model.conv_layer(images_ph,5,3,16,1)
    network = model.pooling_layer(network,5,2)
    network = model.activation_layer(network)   

    #level 2 convolution 
    network = model.conv_layer(network,4,16,32,1)
    network = model.pooling_layer(network,4,2)
    network = model.activation_layer(network)    

    #level 3 convolution
    network=model.conv_layer(network,3,32,64,1)
    network=model.pooling_layer(network,3,2)
    network=model.activation_layer(network)

    #flattening layer
    network,features=model.flattening_layer(network)
   
    #fully connected layer
    network=model.fully_connected_layer(network,features,1024)
    network=model.activation_layer(network)

    #output layer
    network = model.fully_connected_layer(network,1024,number_of_classes)
    return network

#train the Model

def train_model(network,number_of_images):
  
    #find error
    cross_entropy=tf.nn.softmax_cross_entropy_with_logits_v2(logits=network,labels=labels_ph)

    #minize the above error
    #calculate the total mean of all the errors from all the nodes
    cost=tf.reduce_mean(cross_entropy)
    tf.summary.scalar("cost", cost)#for tensorboard visualisation

    #backpropagate in Network to minimize cost
    optimizer=tf.train.AdamOptimizer().minimize(cost)    
    #print(optimizer)
    
    session.run(tf.global_variables_initializer())
    writer = tf.summary.FileWriter(model_save_name, graph=tf.get_default_graph())
    merged = tf.summary.merge_all()
    saver = tf.train.Saver(max_to_keep=4)
    counter=0
    for epoch in range(epochs):
        tools = utils()
        for batch in range(int(number_of_images / batch_size)):
            counter+=1
            images, labels = tools.batch_dispatch()
            if images == None:
                break
            loss,summary = session.run([cost,merged], feed_dict={images_ph: images, labels_ph: labels})
            print('loss', loss)
            session.run(optimizer, feed_dict={images_ph: images, labels_ph: labels})

            print('Epoch number ', epoch, 'batch', batch, 'complete')
            writer.add_summary(summary,counter)
        saver.save(session, model_save_name)

if __name__=="__main__":
    tools = utils()
    model = model_tools()
    network = generate_model()
    number_of_images = sum([len(files) for r, d, files in os.walk(data_path)])
    train_model(network,number_of_images)

#Create a saver object to load the model
saver = tf.train.import_meta_graph(os.path.join('/content/model_checkpoint','.meta'))

graph = tf.get_default_graph()

network = graph.get_tensor_by_name('add_4:0')

im_ph= graph.get_tensor_by_name("Placeholder:0")
label_ph = graph.get_tensor_by_name("Placeholder_1:0")

network  = tf.nn.sigmoid(network)

network

path = '/content/drive/My Drive/Dataset/test'
import pandas as pd
for x,y,imageList in os.walk(path):
  predictedLable = []
  for image in imageList:
      img=cv2.imread(os.path.join(path,image))
      img = cv2.resize(img, (100,100))
      img=img.reshape(1,100,100,3)      
      labels = np.zeros((1, 4))      
      
      #Creating the feed_dict that is required to be feed the io:
      feed_dict_testing = {im_ph: img, label_ph: labels}
      
      result=session.run(network, feed_dict=feed_dict_testing)
      predictedLable.append(np.argmax(result))
  df = pd.DataFrame(list(zip(imageList, predictedLable)), columns = ['imageId','predicted_labels'])

df.to_csv('/content/result.csv')

